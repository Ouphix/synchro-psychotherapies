---
title: "SynchronyShuffleScoresAnalysis"
author: "Thomas Gargot"
date: "19 oct 2016"
output: pdf_document
---

# Clean environment
```{r Clean Environment}
rm(list = ls(all.names = TRUE))
```

# Session info
```{r}
sessionInfo()
```

# Preparation of the session
```{r import libraries, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE}
# To use this script, you must install packages (install.packages()) to install these packages if you don't have them.

# Loading libraries
## For managing data frames easilly : rbinds function
library("plyr")
## For editing string
library("stringr")
```

## Fixed variables
```{r Variables to fix}
FileExtension <- ".MTS.avi_res.csv"

# working directory
# where this report is
#setwd("./Git/Monrado/Reports/")

# blue will refer to father
# red will refer to mother
# green to child
colOrderList <- c("blue","red", "green")

ParticipantsList <- c("father", "mother", "child")
```

```{r cutFrames to translate for ME}
# Import data
cutFrames <- read.csv2("../Data/CSV/Cutframes.csv")
str(cutFrames)

# Change the vector in character and cut the string in two parts minutes and second for the 4 time labels ("CutBefore"  "CutMiddle1" "CutMiddle2" "CutFinal") 
cutFrames$CutBefore <- as.character(cutFrames$CutBefore)
cutFramesCB <- strsplit(cutFrames$CutBefore, split=":")

# Compute the time in minutes from time in minutes and seconds for each video for Cut Before
Cut <- c()
for (i in 1:nrow(cutFrames)){ 
  CutBeforeAlone <- (as.numeric(cutFramesCB[i][[1]][1]) + as.numeric(cutFramesCB[i][[1]][2])/60)
  Cut <- c(Cut, CutBeforeAlone)
  }
cutFrames$CutBeforeMin <- Cut

# Compute the time in minutes from time in minutes and seconds for each video for Cut CutMiddle1
Cut <- c()
cutFrames$CutMiddle1 <- as.character(cutFrames$CutMiddle1)
cutMiddleSplit <- strsplit(cutFrames$CutMiddle1, split=":")
for (i in 1:nrow(cutFrames)){ 
  CutAlone <- (as.numeric(cutMiddleSplit[i][[1]][1]) + as.numeric(cutMiddleSplit[i][[1]][2])/60)
  Cut <- c(Cut, CutAlone)
  }
cutFrames$CutMiddle1Min <- Cut

# Compute the time in minutes from time in minutes and seconds for each video for Cut CutMiddle2
Cut <- c()
cutFrames$CutMiddle2 <- as.character(cutFrames$CutMiddle2)
cutMiddleSplit <- strsplit(cutFrames$CutMiddle2, split=":")
for (i in 1:nrow(cutFrames)){ 
  CutAlone <- (as.numeric(cutMiddleSplit[i][[1]][1]) + as.numeric(cutMiddleSplit[i][[1]][2])/60)
  Cut <- c(Cut, CutAlone)
  }
cutFrames$CutMiddle2Min <- Cut

# Compute the time in minutes from time in minutes and seconds for each video for Cut CutFinal
Cut <- c()
cutFrames$CutFinal <- as.character(cutFrames$CutFinal)
cutSplit <- strsplit(cutFrames$CutFinal, split=":")
for (i in 1:nrow(cutFrames)){ 
  CutAlone <- (as.numeric(cutSplit[i][[1]][1]) + as.numeric(cutSplit[i][[1]][2])/60)
  Cut <- c(Cut, CutAlone)
  }
cutFrames$CutFinalMin <- Cut
Cut <- c()
```

### Data dictionnary of cutFrames dataframe
* **family** : code of the family
* **CutBefore** : when the experimenter leave the room and the interaction begin character string in the form min:sec
* **CutMiddle1** : when the experimenter come back to explain that the participants are asked to have a conflictual discussion, character string in the form min:sec
* **CutMiddle2** : when the experimenter leave and the conflictual discussion begin
Between is the conflictual discussion, character string in the form min:sec
* **CutFinal** : when the experimenter come back to shut down the camera, character string in the form min:sec
* **ChildSex** : Factor variable : Male of Female
* **ParentSex** : Factor variable : Male of Female
* **CutBeforeMin** : when the experimenter leave the room and the interaction begin numeric variable in minutes
* **CutMiddle1Min** : when the experimenter come back to explain that the participants are asked to have a conflictual discussion, numeric variable in minutes
* **CutMiddle2Min** : when the experimenter leave and the conflictual discussion begin
Between is the conflictual discussion, numeric variable in minutes
* **CutFinalMin** : when the experimenter come back to shut down the camera, numeric variable in minutes

# SyncPy utilisation for creating synchrony dataframe
After extracting filtered motion motion history with mean on sliding interval (overlapping interval) of 5 frames
And after puting this data on a CSV file [slideddata.csv](../Data/CSV/filtered/log)

We import this data on python Script with panda module [Call_S_Estimator.py](../Scripts/Call_S_Estimator.py)
This script will compute the synchrony between each dyad of the interaction and of the whole group
It will return a csv file for each video [SSIXXXX.csv](../Data/CSV/Synchrony/log) with XXXX the name of the video (1606, BAJE059 etc) that we can import with R with
this following function

## Import Data
```{r SSIFilesList}
print("SSI Files Directory")
SSIFilesList <- list.files("../Data/CSV/Synchrony/noLog/S_estimator/noShuffle", full.name=TRUE)
SSIFilesList

#print("SSI Shuffle Files Directory")
#SSInoLogShuffledFilesList <- list.files("../Data/CSV/Synchrony/noLog/S_estimator/shuffle", full.name=TRUE)
#SSInoLogShuffledFilesList
```

## Clean Data
```{r SSInolog import}
SSI <- NULL
# Merge data frames by video (shuffle and not shuffle) by column and then merge all the videos together by rows.
# NB list from 34 to 1 because the name of the first video is a number and not a character
for (i in length(SSIFilesList):1){
    print(i)
    #print (SSInoLogFilesList[i])
    SSIalone <- read.csv(SSIFilesList[i])
    print(str(SSIalone))
    print(dim(SSIalone))
 #   SSIShuffleAlone <- read.csv(SSInoLogShuffledFilesList[i])
    #print(SSInoLogShuffledFilesList[i])
    #print(str(SSIShuffleAlone))
 #   print (dim(SSIShuffleAlone))
   # SSITemp <- merge(SSIalone, SSIShuffleAlone, by.x="Time_min", by.y="Time_min")
#    print (dim(SSITemp))
 #   SSI<- rbind.fill(SSI, SSITemp)
     SSI<- rbind.fill(SSI, SSIalone)

    print (dim(SSI))
    #print (str(SSInoLog))
    }
dim(SSI)
#str(SSI[,90:104])
#SSI$video <-as.factor(SSI$video.x)
SSI$video.x <- NULL
SSI$video.y <- NULL
SSI$X.x <- NULL
SSI$Interval.x <- NULL
SSI$Interval.y <- NULL
SSI$X.y <- NULL
SSI$video.y <- NULL
SSI$SSI_pa_ch <- SSI$SSI_mo_ch + SSI$SSI_fa_ch

#SSI <- rename (SSI, c("video.x" = "family"))
#SSInoLog <- rename (SSInoLog, c("X.x" = "SSI-interval"))
#SSInoLog$action <- rep(NA, nrow(SSInoLog))
#SSInoLog[which(video == & timeMin==)]$action
SSI$SSI_pa_ch<-rowSums(SSI[, c("SSI_fa_ch", "SSI_mo_ch")], na.rm=T)

plot(SSI$SSI_pa_ch, type="l", lwd=2, ylim=c(0, 0.8), main="Scores of SSI natural data (in black) and 
  shuffled data (in blue) for all videos", ylab="Synchrony score")

lines(SSI$X0, type="l", col="blue")
for (i in 3:102){
  lines(SSI[,i], type="l", col="blue")
}

#SSI[1:5,3]
#SSI[1:5,102]

#plot(SSI$X0, type="l", col="blue")

#SSIShuffle <- data.frame(video="Name")

```

```{r}
#for (file in SSInoLogShuffledFilesList){
#  print (file)
#   SSIalone <- read.csv(file)
#   print(str(SSIalone))
#}
#   SSIShuffle<- rbind.fill(SSIShuffle, SSIalone)}
#SSIShuffle <- SSIShuffle[-which(SSIShuffle$video=="Name"),]

#SSIShuffle <- merge(SSInoLog, SSIShuffle, by.x="Time_min", by.y="Time_min")

#plot(SSIShuffle$Time_min, SSIShuffle$SSI_fa_ch, type="l", lwd=2)
#dim(SSIShuffle)
#plot(SSIShuffle$Time_min, SSIShuffle[,8], type="l", lwd=2)

#for (i in 8:108){
#  print (i)
#  print(SSIShuffle[,i])
#  lines(SSIShuffle[,i], lty=2)
# }
```

# Annotating data frames noLog
```{r SSInoLog}
SSI <- merge(SSI, cutFrames, by.x="video", by.y="family")
SSI$LabelVideo <- rep(NA, nrow(SSI)) 
SSI[which(SSI$Time_min <= SSI$CutBeforeMin),]$LabelVideo <- "Cut"

SSI[which(SSI$Time_min > SSI$CutBeforeMin & SSI$Time_min < SSI$CutMiddle1Min),]$LabelVideo <- "No Conflict"

SSI[which(SSI$Time_min >= SSI$CutMiddle1Min & SSI$Time_min <= SSI$CutMiddle2Min),]$LabelVideo <- "Cut"

SSI[which(SSI$Time_min > SSI$CutMiddle2Min & SSI$Time_min < SSI$CutFinalMin),]$LabelVideo <- "Conflict"

SSI[which(SSI$Time_min >= SSI$CutFinalMin),]$LabelVideo <- "Cut"
```

## Description of noLogSSI data frame
```{r SSIdf  description , cache=FALSE}
str(SSI)
#View(SSI)
```

### Data dictionnary of SSI data frame
* **family** : code of the family
* **SSI-interval** : interval of SSI
* **Time_min** : Time in minutes
* **SSI_fa_ch** : SSI index of Synchrony between father and child
* **SSI_mo_ch** : SSI index of Synchrony between mother and child
* **SSI** : SSI index of the interaction (father-child or mother-child)
* **CutBefore** : when the experimenter leave the room and the interaction begin character string in the form min:sec
* **CutMiddle1** : when the experimenter come back to explain that the participants are asked to have a conflictual discussion, character string in the form min:sec
* **CutMiddle2** : when the experimenter leave and the conflictual discussion begin
Between is the conflictual discussion, character string in the form min:sec
* **CutFinal** : when the experimenter come back to shut down the camera, character string in the form min:sec
* **ChildSex** : Factor variable : Male of Female
* **ParentSex** : Factor variable : Male of Female
* **CutBeforeMin** : when the experimenter leave the room and the interaction begin numeric variable in minutes
* **CutMiddle1Min** : when the experimenter come back to explain that the participants are asked to have a conflictual discussion, numeric variable in minutes
* **CutMiddle2Min** : when the experimenter leave and the conflictual discussion begin
Between is the conflictual discussion, numeric variable in minutes
* **CutFinalMin** : when the experimenter come back to shut down the camera, numeric variable in minutes
* **LabelVideo** : label of the video if it is related to No Conflict period or Conflict Period 

# Synchrony scores noLog for each dyad
```{r Synchrony scores noLog for each dyad, fig.width=8, fig.height=3.5}
par(mar=c(4,4,4,3), mfrow=c(1,1))
for (i in unique(SSI$family)){
      if (all(!is.na(SSI[which(SSIlog$family==i),]$SSI_mo_ch)==TRUE)){
        plot(SSI[which(SSIlog$family==i),]$Time_min, SSI[which(SSI$family==i),]$SSI_mo_ch, 
             ylim=c(0, 0.3), main=paste("Synchrony scores in", i, "family"), xlab = "Time (minute)", ylab="Synchrony score", lwd=2, type="l", col="red", cex.axis=0.7, xaxp=c(0,length(SSIlog[which(SSIlog$family==i),]$Time_min), length(SSI[which(SSIlog$family==i),]$Time_min)))}
      
      else if(all(!is.na(SSI[which(SSIlog$family==i),]$SSI_fa_ch)==TRUE)){
#    print(str(SSI[which(SSI$family==i),]$SSI_fa_ch))
    plot(SSI[which(SSIlog$family==i),]$Time_min, SSI[which(SSIlog$family==i),]$SSI_fa_ch, ylim=c(0, 0.3), main=paste("Synchrony scores in", i, "family"), xlab = "Time (minute)", ylab="Synchrony score", lwd=2, type="l", xaxp=c(0,length(SSI[which(SSIlog$family==i),]$Time_min), length(SSI[which(SSIlog$family==i),]$Time_min)), col="blue", cex.axis=0.7)}
      else{print("error")}}
```


```{r}
ncSSI <- c()
cSSI <- c()

for (i in unique(SSI$family)){
  print (i)
  nc <- mean(SSI[which(SSI$LabelVideo=="No Conflict" & SSI$family==i),]$SSI)
  print(nc)
  ncSSI <- c(ncSSI, nc)
  co <-mean(SSI[which(SSI$LabelVideo=="Conflict"  & SSI$family==i),]$SSI)
  print (co)
  cSSI <- c(cSSI, co)
}

hist(ncSSI)
hist(cSSI)


SSImean <- data.frame(sort(ncSSI, decreasing = TRUE), sort(cSSI, decreasing = TRUE))
par(mar=c(3,5,3,3))
barplot(as.matrix(SSImean), col=terrain.colors(34), ylab="Synchrony scores", main="Sum of mean synchrony scores for all videos", names.arg = c("No conflict", "Conflict"))

t.test(ncSSI, cSSI, alternative = c("two.sided"),
paired=TRUE, conf.level = 0.95)
```